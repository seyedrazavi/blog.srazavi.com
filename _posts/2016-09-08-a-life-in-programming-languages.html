---
layout: post
published: true
title: A Life in Programming Languages
wordpress_id: 29
wordpress_url: https://srazavi.com/?p=29
date: '2016-09-08 23:20:54 +0100'
date_gmt: '2016-09-08 22:20:54 +0100'
categories:
- Journal
tags:
- Technology
comments: true
---
<p>An autobiography of the programming languages that I have learned, their place in my life and the surrounding technological context.</p>
<h2><!--more--><br />
Age: 9 (1987) - Logo</h2>
<p>I was in primary school and there was a <a href="https://en.wikipedia.org/wiki/BBC_Micro">BBC Micro</a> computer that was on a wheeled trolley. Two by two, we would be given a set time to answer questions on a nature database and an opportunity to "play with the turtle". The turtle would receive instructions which would be interpreted with each press of the enter key.</p>
<p>This was a golden age of the teaching of computing in schools in the UK before someone thought the only thing kids needed to know was word processing and spreadsheets. Luckily, that educational view has mostly passed.</p>
<h3>What I Learned:</h3>
<ul>
<li>How to think logically, going from position A to position B in a set of clear instructions.</li>
<li>The basics of procedural programming.</li>
<li>Also, how to break out of the jail of the running program and see what other fun software the IT guy had installed on the computer.</li>
</ul>
<h2>Age: 10 (1988) - ZX BASIC</h2>
<p>My uncle bought me a Sinclair Spectrum for &pound;50 and I sat in the living room, hogging the TV all weekend. It didn't come with any games and there was no networking. I sat and read the manual cover to cover before finally being able to follow the set listings for I-CHING, a _20 question_ style game and tic-tac-toe. Thus my first real programs were copied, modified and run. Later I would buy any magazines from the newsagent that promised code listings for the Spectrum. I read a few books on adventure game programming and took my first look into ZX assembler to eek out the most of 48 kilobytes of RAM. The happy screeching of data being loaded from tape is still a fond memory.</p>
<h3>What I Learned:</h3>
<ul>
<li>The fundamentals of a computer system (CPU, RAM, Video etc) and a real procedural programming language.</li>
<li>Also, the pain and joy of debugging and the value of backups. Nothing like someone accidentally pulling the plug and losing all the code you wrote for the last few hours, to reinforce that lesson.</li>
<li>I think I was much more patient then as well. I cannot imagine waiting 10 or more minutes for an app to load nowadays!</li>
</ul>
<h2>Age: 11 (1989) - BBC BASIC</h2>
<p>The next school I was at had a few BBC Micros and after showing off to an IT teacher with almost no knowledge of computing, I was allowed to play under supervision. Together we managed to hook up various sensors for measuring pressure, moisture and temperature. Dreams of building a robot were put on hold due to another move to another school. There, I set up our first daisy-chain network and with complete ignorance of how easy this was on Unix systems, I was immensely satisfied to have made a rudimentary chat program between two computers a couple of meters apart.</p>
<p>So began the era of people sitting nearby each other talking via their screens.</p>
<h3>What I Learned:</h3>
<ul>
<li>Hardware can be fun! The BBC Micro with its serial port interfaces were fantastic for probing physical systems.</li>
<li>Signal processing and how to transform raw data into meaningful information.</li>
<li>And even though I didn&rsquo;t know they were called this at the time, what turned out to be some of the most common algorithms and data structures in computing.</li>
</ul>
<h2>Age: 14 (1992) - Mac BASIC</h2>
<p>It was sadly a few more years before I had access to a better home computer than the Spectrum. The school I went to had an Apple Macintosh which was perfect for writing a GUI database application. By now listening to music was everything in my life, so building a lyric database and documenting it for class was the most memorable project. More than this, access to the Apple Macintosh meant I could hide away from the canteen and crowds when needed.</p>
<h3>What I Learned:</h3>
<ul>
<li>Graphical user interfaces and databases. Starting to feel like a modern desktop application.</li>
</ul>
<h2>Age: 15 (1993) - Visual Basic</h2>
<p>The shiny new Windows 3.11 PCs in the computer lab at school had copies of early editions of VB. I learned it for school projects but it all felt quite dumb and mysterious. <em>Drag controls on a frame, double click, write some code to do something with the inputs to the function</em>. Where did it all go? How did the program come together? There was too much magic and not enough understanding. It defied attempts to pull it apart and learn how it worked. This was disappointing.</p>
<p>However, it had its merits. The local Bulletin Board System (BBS), accessed via 14kbps modem had a community which shared VB code. It seemed we all had watched <a href="https://en.wikipedia.org/wiki/WarGames">Wargames</a> and fancied ourselves little hackers. We were script kiddies at best but it was all great fun.</p>
<p>The Internet, mostly in the form of <a href="https://en.wikipedia.org/wiki/Gopher_(protocol)">Gopher</a>&nbsp;and email was entering schools. I was interested but couldn't do much with it using VB. Microsoft was very slow to enter the Internet age.</p>
<h3>What I Learned:</h3>
<ul>
<li>Seeing a lot of other people&rsquo;s code for the first time and having them look at the code I wrote led to vast improvements and exposure to new ideas. Today, with <a href="https://en.wikipedia.org/wiki/Stack_Overflow">Stack Overflow</a>&nbsp;its hard to remember how hard it was for a lonely programmer to work through those huge blockers that inevitably comes when tackling something new.</li>
</ul>
<h2>Age: 16 (1994) - C</h2>
<p>My first introduction to C programming came when I downlowded someone's source code for a basic <a href="https://en.wikipedia.org/wiki/Telnet">telnet</a> application. I didn't understand 95% of the code but I managed to make the necessary changes and compile it to work on my Windows PC. The C programmers were all a lot older than me and spoke in the mystical language of <a href="https://en.wikipedia.org/wiki/Unix">UNIX</a> programming. Naturally, I thought this was cool.</p>
<h3>What I Learned:</h3>
<ul>
<li>Memory management had been something BASIC took care of (more or less) but C made it clear you had all the power, for good or for ill. Pointers to memory blocks and the funky maths you could do with them was like being given access to the bare metal of the operating system.</li>
<li>Socket programming and Internet protocols that allowed nearly real-time networking between computers was revolutionary to me. A sad consequence was I acquired an adolescent snobbery towards script kiddies <em>still</em> using VB.</li>
</ul>
<h2>
Age: 18 (1996) - Active Server Pages</h2>
<p>I learned ASP programming during the first year of university when I should've instead been focused on electromagnetism, relativity or whatever. I did so mainly to sell my services to people who wanted functional websites in the early days of the commercial Internet. My most successful endeavour was building a remote classroom site for a couple of English teachers, hooking up Microsoft Netmeeting and an Access database. I earned more than a years worth of Student Loans out of that.</p>
<p>Most people still thought the Internet was a fad at this point. The tabloids had plenty of scare stories about how it was dangerous and filled with porn and predators. Not much has changed but even the most optimistic or pessimistic projections didn&rsquo;t see how thoroughly the Internet would change everything.</p>
<h3>What I Learned:</h3>
<ul>
<li>There was a living to be made doing Internet things.</li>
<li>This was also my first exposure to object oriented programming. Although ASPs at this time were mostly procedural they drew objects from the world of <a href="https://en.wikipedia.org/wiki/Component_Object_Model">COM</a>&nbsp;into the mix. I was pretty curious how these things were built.</li>
</ul>
<h2>Age: 19 (1997) - C++</h2>
<p>Trying to build complicated Windows packages as your first foray into C++ is with hindsight, a bit mental. C++ is a language where the designer didn't come across a good idea he didn&rsquo;t want to throw in. Only a much more complicated version than was probably needed most of the time. Experienced C++ developers know what to use and when and today&rsquo;s standard C++ library has much improved. But for me back then, the sheer amount of choices and ways to break your code was extremely frustrating. That was before you tried to make something on Windows with its huge numbers of macros, strange API model and its devilish <a href="https://en.wikipedia.org/wiki/Hungarian_notation">Hungrarian notation</a>.</p>
<p>It took me a very long time to get to grips with C++ and only enough to know I wanted off <a href="https://en.wikipedia.org/wiki/Bjarne_Stroustrup">Bjarn's</a>&nbsp;crazy ride as soon as possible.</p>
<h3>What I Learned:</h3>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Object-oriented_programming">Object-oriented programming (OOP)</a>, or at least a wildly fantastic idea of it that I thought would cure all ills in programming. I cringe with embarrassment at the memory of my evangelism of OOP to <a href="https://en.wikipedia.org/wiki/COBOL">COBOL</a> programming colleauges who were dinosaurs about to cash in on <a href="https://en.wikipedia.org/wiki/Year_2000_problem">a cataclysmic event</a>.</li>
<li>I also learned more data structures and algorithms which was a conceptual step up in building any kind of software.</li>
<li>Most features of modern languages that aren't derived from <a href="https://en.wikipedia.org/wiki/Lisp">Lisp based languages</a>, probably had some overly complicated, horrible to debug, version in C++ first.</li>
</ul>
<h2>Age: 20 (1998) - JavaScript</h2>
<p>My first software development job was working with ASP (which I knew), C++ (which I thought I knew) and JS (which I had to learn). The work primarily involved moving serverside JS from Netscape servers to ASP applications on <a href="https://en.wikipedia.org/wiki/Internet_Information_Services">Windows IIS servers</a>. As ASP was a memory hogger and back then 32Mb was a lot of RAM, I would write COM objects in C++ for performant-but-bloated features such as forums or messaging.</p>
<p>There was a lot of Macromedia Shockwave and Flash brochure-ware sites back then but a few early portals and community sites as well. We could not live without our regular fix of <a href="https://en.wikipedia.org/wiki/Slashdot">Slashdot</a>.</p>
<p>Most web sites were written in Perl which I had to understand enough to borrow code from and incorporate into our ASP sites. Some client side Javascript was used but not a great deal as the browsers were not great at rendering JS without incredible slow-downs, memory leaks or crashes.</p>
<p><em>Aside</em>: I used to pity those people who had to maintain someone else&rsquo;s Perl code. In hindsight, the same could be said about anything I wrote myself. Heck, at this point I was super excited for the long-awaited release of another Star Wars movie, so what did I know?</p>
<h3>What I Learned:</h3>
<ul>
<li>Javascript is a neat language which leads to bad design in the wrong hands. Most hands being quite wrong for it.</li>
<li>The Netscape server model for JS defined how server-side applications would look for years to come.</li>
<li>The game of finding the ending curly brace in several thousand lines of code had begun and sadly has never gone away.</li>
</ul>
<h2>
Age: 22 (2000) - Java</h2>
<p>I moved to London in the heat of the dotcom boom and picked up the language that had replaced C / C++ as the dominant platform on the server side. Originally intended for producing applets (generally unresponsive applications which frequently crashed inside of Netscape browsers), its slick garbage collection, multi-platform virtual machine and clean standard library had made it the preferred choice of financial institutions and heavily financed start ups. It wasn&rsquo;t long before a lot of &ldquo;Enterprise&rdquo; features were bolted on and Java was a bloated mess that required encyclopaedic efforts in meta-descriptions to build your basic web application.</p>
<p>The Dotcom boom was a little insane. Even in England, there was silly money thrown at the most ludicrous ideas. I once worked for a startup with offices in St. James Park, with over thirty Java developers, wanting to build a b2b marketplace for the building industry. At a time when a typical construction company may have had one networked PC in their head office.</p>
<p>This was also at the height of the Microsoft vs Sun / Netscape monopoly saga that eventually became nothing more than an irrelevant footnote of history. There were a lot of competing visions for the future of software and almost all of them came true except not in the ways we thought they would. Dumb terminals running just a browser didn&rsquo;t become the norm but cloud-based computing did see a massive shift to Software-as-a-Service. In programming, Java won the argument in most ways and forced Microsoft to move away from C++ and develop C#. Meanwhile, Apple seemed an irrelevance.</p>
<h3>What I Learned:</h3>
<ul>
<li>The value and dangers of a good garbage collector.</li>
<li>I learned about design patterns and how to use them effectively.</li>
<li>The power of a really good, strongly typed compiler in enforcing interfaces.</li>
<li>The flexibility of a byte code virtual machine for portability of code, liberating software from expensive Unix hardware vendors. An amusing fact given it was <a href="https://en.wikipedia.org/wiki/Sun_Microsystems">one such vendor</a> that made the language that did the most to usher in the era of commodity servers.</li>
<li>I also learned about &ldquo;Enterprise" applications and how they made good money for <a href="https://en.wikipedia.org/wiki/IBM">consultants</a>.</li>
<li>I learned about over engineering and how boilerplate code kills the creative soul of programming.</li>
</ul>
<h2>
Age: 24 (2002) - PHP</h2>
<p>Whilst Java would remain the bread-and-butter of my professional work for years to come, I longed for something that produced results more quickly. Something that allowed creativity and would take a few days, rather than a few months to go from idea to working system. I found PHP a good match and built a <a href="https://en.wikipedia.org/wiki/BlogShares">toy application</a> that became bigger than I had expected. I used it professionally on a few projects and learned more than one framework in PHP that tried to bring some hygiene and sanity to what always remained to me, a quick and dirty tool.</p>
<h3>What I Learned:</h3>
<ul>
<li>'When the gods wish to punish us, they answer our prayers' may have been said about PHP. It was simple, easy and oh, so terrible. Some of the worst code I have seen outside of Perl circles is written in PHP. Low maintainability and leaky abstractions, hacky solutions abound.</li>
<li>Efforts over the years to make it move in the direction of more robust languages and frameworks all feel like putting Porsche spoilers on a Austin Allegro. Still surprisingly prevalent and much in fashion thanks to <a href="https://wordpress.com/">some of the most successful web applications</a> ever made. Yes, much of Facebook was originally written in PHP, but that is no excuse for using PHP today.</li>
</ul>
<h2>
Age: 30 (2008) - Ruby</h2>
<p>Ruby was an oasis in the desert to a man who spent nearly a decade working with Java. Its Rails framework seemed at first a bit of a cheap trick. &ldquo;Oh I&rsquo;m sure you can build a basic website in no time but what about when you hit the real obstacles? When you have to build something more bespoke?&rdquo; I asked sceptically. Yet it did not disappoint. Gone was the mountains of unnecessary boilerplate and the forest of XML definitions. Instead, there were sensible conventions and easily readable code. The interpretive, non-static type system, with its <a href="https://en.wikipedia.org/wiki/Duck_typing">duck typing</a> and ability to extend code libraries after the fact, scared me at first but I soon loved the ability to <a href="https://en.wikipedia.org/wiki/Monkey_patch">monkey patch</a> third-party code. Ruby&rsquo;s gem package management system seemed the first plausible step out of the allegorical cave of <a href="https://en.wikipedia.org/wiki/DLL_Hell">DLL hell</a>.</p>
<h3>What I Learned:</h3>
<ul>
<li>I learned to love programming again. Java and the whole commercial scene around it had done an almost thorough job of making me hate coding but Ruby came along and like a man having a mid-life crisis I was in love again.</li>
<li>It made me interested in new approaches to programming that didn&rsquo;t come down the C or object-oriented family trees.</li>
<li>As much as I loved Ruby, it had some issues with performance but thankfully the commodity server and cloud-based computing revolution made this less and less of an issue in most cases. Developer productivity was worth much more than savings on the cost of CPUs or memory, at least in most cases.</li>
<li>All that funky flexibility had its downsides, as the ecosystem became more complicated and prone to unintended consequences. This is still mitigated by locking down gems to a known working version but it does mean upgrading the underlying platform with each release becomes more and more onerous on mature systems.</li>
</ul>
<h2>Age: 34 (2012) - Node.js</h2>
<p>The iPhone had come out in 2007 but I had remained an Android phone guy. Like a lot of Android users, I never got apps. Not in the way iPhone users had loved and relied upon their apps. I liked software that ran in browsers or on the server. Besides, I&rsquo;d built some client software in Java and C++ / Windows and it wasn&rsquo;t much fun. So the mobile revolution didn&rsquo;t really impact my life for a few years. However, by 2012 there was no escaping it and I had joined a mobile software company as a Ruby developer. It wasn&rsquo;t the first choice for server software there, that being PHP and Node.js, which I decided to learn.</p>
<p>I really wanted to like Node and it certainly moved forward the spirit I had discovered in the Ruby community. I built some serious web APIs with it. It was the first server side programming language I&rsquo;d come across that seemed perfectly suited to the age of mobile dominance. It was <a href="https://en.wikipedia.org/wiki/JSON">JSON</a> first and its package manager was as good as Ruby gems. Node was compiled down to byte code and thus more more performant than Ruby.</p>
<h3>What I Learned:</h3>
<ul>
<li>Whilst I&rsquo;d tried <a href="https://en.wikipedia.org/wiki/Test-driven_development">Test-Driven Development (TDD)</a> before, it was with Node that I really made it a cornerstone to how I approached programming. In a way, Node demanded it.</li>
<li>Stylistically, I never could make peace with the JavaScript language. I guess after the beauty of Ruby it was hard to go back to the long files of stacked, indented curly braces.</li>
<li>There are some great ideas in Node but the stand out one is probably the implementation of <a href="https://en.wikipedia.org/wiki/Futures_and_promises">promises</a>.</li>
</ul>
<h2>Age: 34 (2012) - Erlang</h2>
<p>I picked up Erlang to learn more about <a href="https://en.wikipedia.org/wiki/Functional_programming">functional programming</a> and because it was famous for its <a href="https://en.wikipedia.org/wiki/Concurrent_computing">concurrency</a>. I built a few toy projects such as a distributed web crawler and a chat server with it but nothing releasable. I could have just learned the Ruby-like <a href="https://en.wikipedia.org/wiki/Elixir_(programming_language">Elixir</a> that runs on the Erlang virtual machine but I purposefully wanted to grapple with something different.</p>
<h3>What I Learned:</h3>
<ul>
<li>Erlang with its mathematical functional approach and lack of state made highly concurrent systems feasible. Messing with threads, locks and mutexes in Java or C++ was often painful and dangerous.</li>
<li>The syntax for Erlang is a bit wacky (not as wacky as Objective C) and even after a year or two of toying with it, I didn&rsquo;t find it particularly endearing. Nor did I dislike it like I have grown to dislike JavaScript syntax in large applications.</li>
<li>Although Erlang makes writing concurrent code a lot safer and easier, debugging it is still a mind-boggling exercise akin to following the white rabbit down the hole. I think I need a _really_ good reason to use it and wouldn&rsquo;t consider it my first choice for general application development.</li>
</ul>
<h2>
Age: 35 (2013) - Objective-C</h2>
<p>Working in a mobile app shop and not knowing Objective C was like being a second-class citizen so I decided I needed to learn how to make iOS applications. After a few toy applications, I even managed to release a little 2D game on the App Store.</p>
<h3>What I Learned:</h3>
<ul>
<li>Objective C is a mutt of a language, half Smalltalk and half C.</li>
<li>The Cocoa libraries are quite nice and development of an iOS app far more satisfying and straightforward than building an Android application with Java.</li>
<li>However, Objective C is in some ways the PHP of mobile applications: It lends itself to convoluted codebases that break <a href="https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">every good principle</a> of software design. Perhaps that&rsquo;s a social issue - young hackers looking to make money do so with PHP and Objective C - or perhaps it's because most apps are here today and gone tomorrow so maintainability is an after thought.</li>
</ul>
<h2>
Age: 36 (2014) - C#</h2>
<p>I&rsquo;d seen enough C# before to know it was very, very similar to Java without some of the ugly features and the ecosystem polluted by a thousand vendors taking a dump in the water. It was, however, mostly a Windows platform language in my eyes and I lived in the part of the cloud that ran on cheap Linux servers. However, the foray into Objective C had stirred a longing for a mobile application language that was better. So the opportunity to work with the Xamarin platform was an opportunity to take C# seriously.</p>
<h3>What I Learned:</h3>
<ul>
<li>C# is an evolution over Java in subtle but important ways. For example, its implementation of <a href="https://en.wikipedia.org/wiki/Generic_programming">generics</a>&nbsp;seems superior.</li>
<li>It is statically typed which made debugging it a lot easier and notably the fastest language I had in my arsenal short of C / C++.</li>
<li>Building Cocoa apps in a clean way was a joy even if Xamarin has some rough edges and cross-platform development remains a costly endeavour.</li>
</ul>
<h2>
Age: 37 (2015) - Swift</h2>
<p>Apple&rsquo;s next generation mobile programming language had been out for a year before I took to learning it and building some toy apps with it. It was a great improvement over Objective C but it was still in a state of flux. Mostly I wanted to know whether, if asked, I would recommend using it over Objective C. At the time of writing, its a no brainer: yes, yes I would.</p>
<h3>What I Learned:</h3>
<ul>
<li>Swift has picked up a lot of good ideas from elsewhere and puts it together very nicely. Some aspects seem clunky to me but in the process of being ironed out since it went open source.</li>
<li>It is protocol oriented (which is similar to Go&rsquo;s interfaces) and it brought <a href="https://en.wikipedia.org/wiki/Option_type">option types</a> in play from functional programming languages as well.</li>
<li>The fact it treats the Cocoa system as a first-class citizen makes building apps with it a lot less hassle than with Objective C. Outside of this ecosystem, I&rsquo;m not so sure about efforts to bring Swift to the server.</li>
</ul>
<h2>
Age: 38 (2016) - Rust &amp; Go</h2>
<p>If you want to be a technologist, you have got to keep learning. Even when I'm not doing a lot of code writing in my day job, I need to understand current trends and expose myself to new ideas. So I&rsquo;m learning two languages at the moment, both of them system languages that descend from the C family. At first they may appear quite similar but they intend towards different goals.</p>
<p>Rust makes memory management something you can do safely and manually, without a garbage collector. This gives it reach into lower levels of system programming than anything other than C or C++.</p>
<p>Go is relatively simple compared to Rust. It takes a minimalistic approach compared to C# or Java and it serves a similar niche of programming as these languages.</p>
<p>Rust is also a bit newer than Go and in a more volatile state and therefore has a less mature community of libraries and tools.</p>
<p>Its too early to say what I will learn from these languages nor which will prove to be the language of choice in the industry going forward but I am enjoying the learning process. Each language opens up a new way of thinking about software and our relationship with technology. I&rsquo;m sure I&rsquo;ll keep picking up new programming languages as long as people keep inventing them and I have a mind capable of absorbing them.</p>
